devtools::document()
devtools::document()
library(MASS)
#inputs
num_hap=6
length_hap=5
n0=1000
n1=1000
#intercept1=-0.5
#intercept2=5
base_prev1=0.05
base_prev2=0.05
d=0
rho=0.7
sigma1=3
sigma2=3
hap_mat=matrix(nrow=num_hap,ncol=length_hap)
hap_mat[1,]=c(0,1,1,0,0)
hap_mat[2,]=c(1,0,1,0,0)
hap_mat[3,]=c(1,1,0,1,1)
hap_mat[4,]=c(1,1,1,0,0)
hap_mat[5,]=c(1,1,1,1,1)
hap_mat[6,]=c(1,0,0,1,1)
#hap_mat[7,]=c(1,1,1,0,1)
#hap_mat[8,]=c(1,1,1,1,1)
#hap_mat[9,]=c(1,0,0,1,1)
f=c(0.3,0.005,0.01,0.155,0.11,0.42)
beta1=c(0,0,2,0,0,0)
beta2=c(0,0,-2,0,0,0)
#OR1=c(4,1,1,1,1,1)
#OR2=c(1,3,1,1,1,1)
#beta1=log(OR1)
#beta2=log(OR2)
#haplotype pair matrix
pair_num=num_hap*(num_hap+1)/2
pair_mat=matrix(nrow=pair_num,ncol=3)
k=1
for( i in 1:num_hap){
for(j in i:num_hap){
pair_mat[k,1]=i
pair_mat[k,2]=j
if(i==j){
pair_mat[k,3]=d*f[i]+(1-d)*f[i]*f[i]
}else{
pair_mat[k,3]=2*(1-d)*f[i]*f[j]
}
k=k+1
}
}
sum(pair_mat[,3])
Y1=rep(0,n0+n1)
Y2=rep(0,n0+n1)
SNP_mat=matrix(nrow=n0+n1,ncol=2*length_hap)
tot_sam=0
case_num=0
control_num=0
while(tot_sam<n0+n1){
#generate x
gen_hap_pair=rmultinom(1, size = 1, prob=pair_mat[,3])
which_pair=0
for(i in 1:pair_num){
if(gen_hap_pair[i]==1){which_pair=i}
}
hap1=pair_mat[which_pair,1]
hap2=pair_mat[which_pair,2]
x=rep(0,(num_hap-1))
for(i in 1:(num_hap-1)){
if(hap1==i){
x[i]=x[i]+1
}
if(hap2==i){
x[i]=x[i]+1
}
}
#generate y1 & y2
mean1=log(base_prev1/(1-base_prev1))
mean2=log(base_prev2/(1-base_prev2))
for(i in 1:(num_hap-1)){
mean1=mean1+x[i]*beta1[i]
mean2=mean2+x[i]*beta2[i]
}
mu=c(mean1,mean2)
Sigma=matrix(c(sigma1^2, sigma1*sigma2*rho,sigma1*sigma2*rho,sigma2^2),2,2)
y_star=mvrnorm(1, mu, Sigma)
y1=0
y2=0
if(y_star[1]>0){y1=1}
if(y_star[2]>0){y2=1}
#record simulation
#control in total
if(((y1==0)&&(y2==0))&&(control_num<n0)){
tot_sam=tot_sam+1
control_num=control_num+1
Y1[tot_sam]=y1
Y2[tot_sam]=y2
k=1
for(i in 1:length_hap){
SNP_mat[tot_sam,k]=hap_mat[hap1,i]
SNP_mat[tot_sam,k+1]=hap_mat[hap2,i]
k=k+2
}
}
#case in total
if(((y1==1)||(y2==1))&&(case_num<n1)){
tot_sam=tot_sam+1
case_num=case_num+1
Y1[tot_sam]=y1
Y2[tot_sam]=y2
k=1
for(i in 1:length_hap){
SNP_mat[tot_sam,k]=hap_mat[hap1,i]
SNP_mat[tot_sam,k+1]=hap_mat[hap2,i]
k=k+2
}
}
}
dat=data.frame(Y1,Y2,SNP_mat)
write.table(dat,file="6hap_input_rho07_S3.txt",row.names =F)
library(MASS)
#inputs
num_hap=6
length_hap=5
n0=1000
n1=1000
#intercept1=-0.5
#intercept2=5
base_prev1=0.05
base_prev2=0.05
d=0
rho=0.7
sigma1=3
sigma2=3
hap_mat=matrix(nrow=num_hap,ncol=length_hap)
hap_mat[1,]=c(0,1,1,0,0)
hap_mat[2,]=c(1,0,1,0,0)
hap_mat[3,]=c(1,1,0,1,1)
hap_mat[4,]=c(1,1,1,0,0)
hap_mat[5,]=c(1,1,1,1,1)
hap_mat[6,]=c(1,0,0,1,1)
#hap_mat[7,]=c(1,1,1,0,1)
#hap_mat[8,]=c(1,1,1,1,1)
#hap_mat[9,]=c(1,0,0,1,1)
f=c(0.3,0.005,0.01,0.155,0.11,0.42)
beta1=c(0,0,2,0,0,0)
beta2=c(0,0,-2,0,0,0)
#OR1=c(4,1,1,1,1,1)
#OR2=c(1,3,1,1,1,1)
#beta1=log(OR1)
#beta2=log(OR2)
#haplotype pair matrix
pair_num=num_hap*(num_hap+1)/2
pair_mat=matrix(nrow=pair_num,ncol=3)
k=1
for( i in 1:num_hap){
for(j in i:num_hap){
pair_mat[k,1]=i
pair_mat[k,2]=j
if(i==j){
pair_mat[k,3]=d*f[i]+(1-d)*f[i]*f[i]
}else{
pair_mat[k,3]=2*(1-d)*f[i]*f[j]
}
k=k+1
}
}
sum(pair_mat[,3])
Y1=rep(0,n0+n1)
Y2=rep(0,n0+n1)
SNP_mat=matrix(nrow=n0+n1,ncol=2*length_hap)
tot_sam=0
case_num=0
control_num=0
while(tot_sam<n0+n1){
#generate x
gen_hap_pair=rmultinom(1, size = 1, prob=pair_mat[,3])
which_pair=0
for(i in 1:pair_num){
if(gen_hap_pair[i]==1){which_pair=i}
}
hap1=pair_mat[which_pair,1]
hap2=pair_mat[which_pair,2]
x=rep(0,(num_hap-1))
for(i in 1:(num_hap-1)){
if(hap1==i){
x[i]=x[i]+1
}
if(hap2==i){
x[i]=x[i]+1
}
}
#generate y1 & y2
mean1=log(base_prev1/(1-base_prev1))
mean2=log(base_prev2/(1-base_prev2))
for(i in 1:(num_hap-1)){
mean1=mean1+x[i]*beta1[i]
mean2=mean2+x[i]*beta2[i]
}
mu=c(mean1,mean2)
Sigma=matrix(c(sigma1^2, sigma1*sigma2*rho,sigma1*sigma2*rho,sigma2^2),2,2)
y_star=mvrnorm(1, mu, Sigma)
y1=0
y2=0
if(y_star[1]>0){y1=1}
if(y_star[2]>0){y2=1}
#record simulation
#control in total
if(((y1==0)&&(y2==0))&&(control_num<n0)){
tot_sam=tot_sam+1
control_num=control_num+1
Y1[tot_sam]=y1
Y2[tot_sam]=y2
k=1
for(i in 1:length_hap){
SNP_mat[tot_sam,k]=hap_mat[hap1,i]
SNP_mat[tot_sam,k+1]=hap_mat[hap2,i]
k=k+2
}
}
#case in total
if(((y1==1)||(y2==1))&&(case_num<n1)){
tot_sam=tot_sam+1
case_num=case_num+1
Y1[tot_sam]=y1
Y2[tot_sam]=y2
k=1
for(i in 1:length_hap){
SNP_mat[tot_sam,k]=hap_mat[hap1,i]
SNP_mat[tot_sam,k+1]=hap_mat[hap2,i]
k=k+2
}
}
}
dat=data.frame(Y1,Y2,SNP_mat)
write.table(dat,file="6hap_input_rho07_S3.txt",row.names =F)
setwd("C:/Users/xcass/OneDrive/Documents")
LBL.ex3 = read.table("6hap_input_rho07_S3.txt", header = T)
save(LBL.ex3, file = "LBL.ex3.rda")
install.packages(""hapassoc)
install.packages("hapassoc")
install.packages("dummy")
?quantile
?dummy
install.packages("dummies")
library(hapassoc)
library(LBLGXE)
data("LBL.ex3")
head(LBL.ex3,3)
library(hapassoc)
LBL(LBL.ex3, twoBinaryPheno = T, burn.in = 1000, num.it = 2000)
LBL(LBL.ex3, numSNPs=5, twoBinaryPheno = T, burn.in = 1000, num.it = 2000)
library(LBLGXE)
LBL(LBL.ex3, numSNPs=5, twoBinaryPheno = T, burn.in = 1000, num.it = 2000)
library(LBLGXE)
library(LBLGXE)
LBL(LBL.ex3, numSNPs=5, twoBinaryPheno = T, burn.in = 1500, num.it = 3000)
library(LBLGXE)
library(hapassoc)
data("LBL.ex3")
LBL(LBL.ex3, numSNPs = 5, twoBinaryPheno = T, burn.in = 2000, num.it = 4000)
LBL(LBL.ex3, numSNPs = 5, twoBinaryPheno = T, burn.in = 1000, num.it = 2000)
devtools::build_manual()
devtools::build_manual()
library(LBLGXE)
?`LBLGXE-package`
?LBL
devtools::build_manual()
library(LBLGXE)
library(hapassoc)
library(LBLGXE)
library(LBLGXE)
library(LBLGXE)
library(LBLGXE)
devtools::build_manual()
library(LBLGXE)
library(LBLGXE)
library(hapassoc)
data("LBL.ex3")
LBL(LBL.ex3, numSNPs = 5, burn.in = 1000, num.it = 2000)
LBL(LBL.ex3, numSNPs = 5, twoBinaryPheno = T, burn.in = 1000, num.it = 2000)
library(LBLGXE)
LBL(LBL.ex3, numSNPs = 5, twoBinaryPheno = T, burn.in = 1000, num.it = 2000)
library(LBLGXE)
LBL(LBL.ex3, numSNPs = 5, twoBinaryPheno = T, burn.in = 100, num.it = 1000)
library(LBLGXE)
LBL(LBL.ex3, numSNPs = 5, twoBinaryPheno = T, burn.in = 100, num.it = 1000)
devtools::build_manual()
devtools::build_manual()
library(LBLGXE)
library(LBLGXE)
LBL(LBL.ex3, numSNPs = 5, twoBinaryPheno = T, burn.in = 100, num.it = 1000)
library(hapassoc)
LBL(LBL.ex3, numSNPs = 5, twoBinaryPheno = T, burn.in = 100, num.it = 1000)
devtools::build_manual()
devtools::document()
data("LBL.ex1")
head(LBL.ex1)
data("LBL.ex2")
head(LBL.ex2)
data("LBL.ex3")
head(LBL.ex3)
devtools::document()
tools::package_native_routine_registration_skeleton(".")
devtools::document()
devtools::document()
library(LBLGXE)
library(LBLGXE)
?LBLGXE
?LBL
data(LBL.ex1)
data(LBL.ex2)
data(LBL.ex3)
library(hapassoc)
library(dummies)
LBL(LBL.ex1, numSNPs=5, burn.in=100, num.it=1000)
LBL(LBL.ex1, numSNPs=5, interaction.model="u", burn.in=100, num.it=1000)
LBL(LBL.ex2, numSNPs=5, complex.sampling=TRUE, n.stra=1, names.dep="stra",
burn.in=100, num.it=1000)
LBL(LBL.ex3, numSNPs=5, twoBinaryPheno=TRUE, burn.in=100, num.it=1000)
library(LBLGXE)
install_github("MorningXY/LBLGXE_version1.4/LBLGXE")
library(devtools)
install_github("MorningXY/LBLGXE_version1.4/LBLGXE")
library(devtools)
install_github("MorningXY/LBLGXE")
install_github("MorningXY/LBLGXE_v1.4/LBLGXE")
install_github("MorningXY/LBLGXE_v1.4")
install_github("MorningXY/LBLGXE_v1.4")
library(LBLGXE)
?LBL
data(LBL.ex1)
# This dataset consists of affection status, complex sampling weights, a binary stratifying
# variable, a binary environmental covariate, and SNP data.
data(LBL.ex2)
# This dataset consists of two correlated affection statuses, no environmental covariate,
#and SNP data.
data(LBL.ex3)
# Install hapassoc and dummies package
library(hapassoc)
library(dummies)
# Run LBL to make inference on haplotype associations and interactions. Note the default
# setting for burn.in and num.it are larger in the LBL function. However, you may want to
# use smaller numbers for a quick check to make sure the package is loaded properly. With
# such shorts runs, the results may not be meaningful.
## Analyzing LBL.ex1 under G-E independence assumption.
out.LBL<-LBL(LBL.ex1, numSNPs=5, burn.in=100, num.it=1000)
## Analyzing LBL.ex1 under uncertainty of G-E independence assumption.
out.LBL<-LBL(LBL.ex1, numSNPs=5, interaction.model="u", burn.in=100, num.it=1000)
## Analyzing LBL.ex2 which comes from complex sampling design with frequency matching.
out.LBL<-LBL(LBL.ex2, numSNPs=5, complex.sampling=TRUE, n.stra=1, names.dep="stra",
burn.in=100, num.it=1000)
## Analyzing LBL.ex3 using the bivariate LBL method.
out.LBL<-LBL(LBL.ex3, numSNPs=5, twoBinaryPheno=TRUE, burn.in=100, num.it=1000)
install_github(“MorningXY/LBLGXE_v1.4”)
install_github("MorningXY/LBLGXE_v1.4")
library(devtools)
install_github("MorningXY/LBLGXE_v1.4")
install_github("MorningXY/LBLGXE_v1.4", force = T)
data("LBL.ex1")
head(LBL.ex1)
data("LBL.ex2")
data("LBL.ex3")
head(LBL.ex2)
head(LBL.ex3)
LBL(LBL.ex1, numSNPs=5, burn.in=100, num.it=1000)
library(LBLGXE)
LBL(LBL.ex1, numSNPs=5, burn.in=100, num.it=1000)
LBL(LBL.ex1, numSNPs=5, interaction.model="u", burn.in=100, num.it=1000)
LBL(LBL.ex2, numSNPs=5, complex.sampling=TRUE, n.stra=1, names.dep="stra",
burn.in=100, num.it=1000)
LBL(LBL.ex2, numSNPs=5, complex.sampling=TRUE, n.stra=1, names.dep="stra",
burn.in=100, num.it=1000)
LBL(LBL.ex3, numSNPs=5, twoBinaryPheno=TRUE, burn.in=100, num.it=1000)
devtools::document()
devtools::document()
library(LBLGXE)
library(LBLGXE)
